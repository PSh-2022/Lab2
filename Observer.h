#ifndef OBSERVER_H
#define OBSERVER_H
#include <iostream>
#include <QString>

/*Наблюдатель- это поведенческий паттерн проектирования,
который создаёт механизм подписки, позволяющий одним
объектам следить и реагировать на события, происходящие в
других объектах.*/

/*Абстрактный класс в C++ - это класс, в котором объявлена хотя
бы одна чисто виртуальная функция.
 * абстрактный класс: необходимо создать
семейство классов (много разновидностей объекта),
при этом нужно вынести общую реализацию и поведение в
отдельный класс. Останется переопределить/дописать только
специфичные для каждого класса методы (у каждого
разновидности объекта свое поведение) и/или расширить
функциональность класса.*/
/*Отличия между интерфейсом и абстрактным классом
1. Каждый интерфейс является абстрактным классом, не каждый
абстрактный класс – интерфейс.
2. Интерфейс содержит только public секцию, абстрактный класс не
имеет ограничений.
3. Интерфейс содержит только pure virtual methods, абстрактный класс
может содержать и поля, и не виртуальные методы.*/

/*представляет интерфейс
включающий метод, который должен вызываться
при каждом изменении.*/
class IObserver//интерфейс - наблюдатель
{   /* Виртуальный метод (виртуальная функция) — это метод класса, который может быть переопределён в классах-наследниках так,
    * что конкретная реализация метода для вызова будет определяться во время исполнения.
 */
public:
 virtual void Update(bool fileExist, int size, QString fileName) = 0; //метод, обновляющий информацию о состоянии файла
/*Чисто виртуальный метод (как здесь) - метод, позволяющий создавать объект класса только как подобъект в классе-наследнике*/
/*Следовательно, объекты абстрактного класса нельзя создавать.*/
};
//класс, реализующий интерфейс - наблюдатель
/*Эти классы должны следовать общему интерфейсу
IObserver, чтобы ASubject не зависел от конкретных
классов наблюдателей.*/
/*выполняют определенные действия в
ответ на оповещение, пришедшее от ASubject.*/
class ConsoleFile : public IObserver//создание файла
{
    static QString name; //название файла
    static bool fileExist; //отметка о существовании файла
    static int size;  //размер файла
    ConsoleFile()= default;//Шаг 4: конструктор, приватный
    ~ConsoleFile()= default;// деструктор, приватный
    ConsoleFile(const ConsoleFile&)=delete;//закрываем конструктор копирования
    ConsoleFile& operator=(const ConsoleFile&)=delete;//и оператор присваивания тоже закрываем
    //стандарт языка С++11
    //функция спецификатора delete - явное ограничение доступа к специальным методам класса(конструкторам, деструкторам, конструкторам перемещения, операторам присваивания и т. п.)
    //функция спецификатора default - указать тот метод класса, который компилятору предписывается использовать по умолчанию(конструктор класса, который объявляется без параметров)
 public:
       /* Одиночка скрывает от клиентов все способы создания нового объекта, кроме
        специального метода. Этот метод либо создаёт объект, либо отдаёт
        существующий объект, если он уже был создан.(в нашем случае создает объект)*/
        static ConsoleFile& instance(){
            // согласно стандарту, этот код ленивый и потокобезопасный
            //Шаг 3: ленивая инициализация - создание объекта при первом вызове метода
            //Потоковая безопасность — концепция программирования, применимая к многопоточным программам. Код потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно.
            //Поток выполнения — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы.
            static ConsoleFile observer;//Шаг 1: Локальная статическая переменная в функции будет вызвана тогда и только тогда, когда будет вызвана сама функция
            return observer;
        }; //Шаг 2: статическая создающий метод. Используется для получения одиночки
    void Update(bool fileExist, int size, QString fileName); // метод, обновляющий информацию о состоянии файла
};
#endif // OBSERVER_H
